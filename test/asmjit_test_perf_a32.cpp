// This file is part of AsmJit project <https://asmjit.com>
//
// See asmjit.h or LICENSE.md for license and copyright information
// SPDX-License-Identifier: Zlib

#include <asmjit/core.h>

#if !defined(ASMJIT_NO_AARCH32)
#include <asmjit/a32.h>

#include <limits>
#include <stdio.h>
#include <string.h>

#include "asmjit_test_perf.h"

using namespace asmjit;

// Generates a long sequence of GP instructions.
template<typename Emitter>
static void generateGpSequenceInternal(
  Emitter& cc,
  const a32::Gp& a, const a32::Gp& b, const a32::Gp& c, const a32::Gp& d) {

  using namespace asmjit::a32;

  cc.mov(a, 0);
  cc.mov(b, 1);
  cc.mov(c, 2);
  cc.mov(d, 3);

  cc.adc(a, b, c, lsl(d));
  cc.adc(a, b, c, lsr(d));
  cc.adc(a, b, c, asr(d));
  cc.adc(a, b, c, ror(d));
  cc.adc(a, b, c, lsl(8));
  cc.adc(a, b, c, lsr(8));
  cc.adc(a, b, c, asr(8));
  cc.adc(a, b, c, ror(8));
  cc.adc(a, b, 0xFF);
  cc.adc(a, b, 0xFF00);
  cc.adc(a, b, 0xFF000000);
  cc.adc(a, b, 0xF000000F);
  cc.adcs(a, b, c, lsl(d));
  cc.adcs(a, b, c, lsr(d));
  cc.adcs(a, b, c, asr(d));
  cc.adcs(a, b, c, ror(d));
  cc.adcs(a, b, c, lsl(8));
  cc.adcs(a, b, c, lsr(8));
  cc.adcs(a, b, c, asr(8));
  cc.adcs(a, b, c, ror(8));
  cc.adcs(a, b, 0xFF);
  cc.adcs(a, b, 0xFF00);
  cc.adcs(a, b, 0xFF000000);
  cc.adcs(a, b, 0xF000000F);
  cc.add(a, b, c, lsl(d));
  cc.add(a, b, c, lsr(d));
  cc.add(a, b, c, asr(d));
  cc.add(a, b, c, ror(d));
  cc.add(a, b, c, lsl(8));
  cc.add(a, b, c, lsr(8));
  cc.add(a, b, c, asr(8));
  cc.add(a, b, c, ror(8));
  cc.add(a, b, 0xFF);
  cc.add(a, b, 0xFF00);
  cc.add(a, b, 0xFF000000);
  cc.add(a, b, 0xF000000F);
  cc.adds(a, b, c, lsl(d));
  cc.adds(a, b, c, lsr(d));
  cc.adds(a, b, c, asr(d));
  cc.adds(a, b, c, ror(d));
  cc.adds(a, b, c, lsl(8));
  cc.adds(a, b, c, lsr(8));
  cc.adds(a, b, c, asr(8));
  cc.adds(a, b, c, ror(8));
  cc.adds(a, b, 0xFF);
  cc.adds(a, b, 0xFF00);
  cc.adds(a, b, 0xFF000000);
  cc.adds(a, b, 0xF000000F);
  cc.and_(a, b, c, lsl(d));
  cc.and_(a, b, c, lsr(d));
  cc.and_(a, b, c, asr(d));
  cc.and_(a, b, c, ror(d));
  cc.and_(a, b, c, lsl(8));
  cc.and_(a, b, c, lsr(8));
  cc.and_(a, b, c, asr(8));
  cc.and_(a, b, c, ror(8));
  cc.and_(a, b, 0xFF);
  cc.and_(a, b, 0xFF00);
  cc.and_(a, b, 0xFF000000);
  cc.and_(a, b, 0xF000000F);
  cc.ands(a, b, c, lsl(d));
  cc.ands(a, b, c, lsr(d));
  cc.ands(a, b, c, asr(d));
  cc.ands(a, b, c, ror(d));
  cc.ands(a, b, c, lsl(8));
  cc.ands(a, b, c, lsr(8));
  cc.ands(a, b, c, asr(8));
  cc.ands(a, b, c, ror(8));
  cc.ands(a, b, 0xFF);
  cc.ands(a, b, 0xFF00);
  cc.ands(a, b, 0xFF000000);
  cc.ands(a, b, 0xF000000F);
  cc.asr(a, b, c);
  cc.asr(a, b, 3);
  cc.asrs(a, b, c);
  cc.asrs(a, b, 3);
  cc.bfc(a, 3, 5);
  cc.bfi(a, b, 3, 5);
  cc.bic(a, b, c, lsl(d));
  cc.bic(a, b, c, lsr(d));
  cc.bic(a, b, c, asr(d));
  cc.bic(a, b, c, ror(d));
  cc.bic(a, b, c, lsl(8));
  cc.bic(a, b, c, lsr(8));
  cc.bic(a, b, c, asr(8));
  cc.bic(a, b, c, ror(8));
  cc.bic(a, b, 0xFF);
  cc.bic(a, b, 0xFF00);
  cc.bic(a, b, 0xFF000000);
  cc.bic(a, b, 0xF000000F);
  cc.bics(a, b, c, lsl(d));
  cc.bics(a, b, c, lsr(d));
  cc.bics(a, b, c, asr(d));
  cc.bics(a, b, c, ror(d));
  cc.bics(a, b, c, lsl(8));
  cc.bics(a, b, c, lsr(8));
  cc.bics(a, b, c, asr(8));
  cc.bics(a, b, c, ror(8));
  cc.bics(a, b, 0xFF);
  cc.bics(a, b, 0xFF00);
  cc.bics(a, b, 0xFF000000);
  cc.bics(a, b, 0xF000000F);
  cc.clz(a, b);
  cc.cmn(a, b, lsl(c));
  cc.cmn(a, b, lsr(c));
  cc.cmn(a, b, asr(c));
  cc.cmn(a, b, ror(c));
  cc.cmn(a, b, lsl(8));
  cc.cmn(a, b, lsr(8));
  cc.cmn(a, b, asr(8));
  cc.cmn(a, b, ror(8));
  cc.cmn(a, 0xFF);
  cc.cmn(a, 0xFF00);
  cc.cmn(a, 0xFF000000);
  cc.cmn(a, 0xF000000F);
  cc.cmp(a, b, lsl(c));
  cc.cmp(a, b, lsr(c));
  cc.cmp(a, b, asr(c));
  cc.cmp(a, b, ror(c));
  cc.cmp(a, b, lsl(8));
  cc.cmp(a, b, lsr(8));
  cc.cmp(a, b, asr(8));
  cc.cmp(a, b, ror(8));
  cc.cmp(a, 0xFF);
  cc.cmp(a, 0xFF00);
  cc.cmp(a, 0xFF000000);
  cc.cmp(a, 0xF000000F);
  cc.crc32b(a, b, c);
  cc.crc32cb(a, b, c);
  cc.crc32ch(a, b, c);
  cc.crc32cw(a, b, c);
  cc.crc32h(a, b, c);
  cc.crc32w(a, b, c);
  cc.eor(a, b, c, lsl(d));
  cc.eor(a, b, c, lsr(d));
  cc.eor(a, b, c, asr(d));
  cc.eor(a, b, c, ror(d));
  cc.eor(a, b, c, lsl(8));
  cc.eor(a, b, c, lsr(8));
  cc.eor(a, b, c, asr(8));
  cc.eor(a, b, c, ror(8));
  cc.eor(a, b, 0xFF);
  cc.eor(a, b, 0xFF00);
  cc.eor(a, b, 0xFF000000);
  cc.eor(a, b, 0xF000000F);
  cc.eors(a, b, c, lsl(d));
  cc.eors(a, b, c, lsr(d));
  cc.eors(a, b, c, asr(d));
  cc.eors(a, b, c, ror(d));
  cc.eors(a, b, c, lsl(8));
  cc.eors(a, b, c, lsr(8));
  cc.eors(a, b, c, asr(8));
  cc.eors(a, b, c, ror(8));
  cc.eors(a, b, 0xFF);
  cc.eors(a, b, 0xFF00);
  cc.eors(a, b, 0xFF000000);
  cc.eors(a, b, 0xF000000F);
  cc.ldr(a, ptr(b, c));
  cc.ldr(a, ptr_pre(b, c));
  cc.ldr(a, ptr_post(b, c));
  cc.ldr(a, ptr(b, 4));
  cc.ldr(a, ptr_pre(b, 4));
  cc.ldr(a, ptr_post(b, 4));
  cc.ldrb(a, ptr(b, c));
  cc.ldrb(a, ptr_pre(b, c));
  cc.ldrb(a, ptr_post(b, c));
  cc.ldrb(a, ptr(b, 4));
  cc.ldrb(a, ptr_pre(b, 4));
  cc.ldrb(a, ptr_post(b, 4));
  cc.ldrbt(a, ptr_post(b, c));
  cc.ldrbt(a, ptr_post(b, 4));
  cc.ldrh(a, ptr(b, c));
  cc.ldrh(a, ptr_pre(b, c));
  cc.ldrh(a, ptr_post(b, c));
  cc.ldrh(a, ptr(b, 4));
  cc.ldrh(a, ptr_pre(b, 4));
  cc.ldrh(a, ptr_post(b, 4));
  cc.ldrht(a, ptr_post(b, c));
  cc.ldrht(a, ptr_post(b, 4));
  cc.ldrsb(a, ptr(b, c));
  cc.ldrsb(a, ptr_pre(b, c));
  cc.ldrsb(a, ptr_post(b, c));
  cc.ldrsb(a, ptr(b, 4));
  cc.ldrsb(a, ptr_pre(b, 4));
  cc.ldrsb(a, ptr_post(b, 4));
  cc.ldrsbt(a, ptr_post(b, c));
  cc.ldrsbt(a, ptr_post(b, 4));
  cc.ldrsh(a, ptr(b, c));
  cc.ldrsh(a, ptr_pre(b, c));
  cc.ldrsh(a, ptr_post(b, c));
  cc.ldrsh(a, ptr(b, 4));
  cc.ldrsh(a, ptr_pre(b, 4));
  cc.ldrsh(a, ptr_post(b, 4));
  cc.ldrsht(a, ptr_post(b, 4));
  cc.ldrsht(a, ptr_post(b, c));
  cc.ldrt(a, ptr_post(b, c));
  cc.ldrt(a, ptr_post(b, 4));
  cc.lsl(a, b, 3);
  cc.lsl(a, b, c);
  cc.lsls(a, b, 3);
  cc.lsls(a, b, c);
  cc.lsr(a, b, 3);
  cc.lsr(a, b, c);
  cc.lsrs(a, b, 3);
  cc.lsrs(a, b, c);
  cc.mla(a, b, c, d);
  cc.mlas(a, b, c, d);
  cc.mls(a, b, c, d);
  cc.mov(a, b, lsl(c));
  cc.mov(a, b, lsr(c));
  cc.mov(a, b, asr(c));
  cc.mov(a, b, ror(c));
  cc.mov(a, b, lsl(8));
  cc.mov(a, b, lsr(8));
  cc.mov(a, b, asr(8));
  cc.mov(a, b, ror(8));
  cc.mov(a, 0xFF);
  cc.mov(a, 0xFF00);
  cc.mov(a, 0xFF000000);
  cc.mov(a, 0xF000000F);
  cc.movs(a, b, lsl(c));
  cc.movs(a, b, lsr(c));
  cc.movs(a, b, asr(c));
  cc.movs(a, b, ror(c));
  cc.movs(a, b, lsl(8));
  cc.movs(a, b, lsr(8));
  cc.movs(a, b, asr(8));
  cc.movs(a, b, ror(8));
  cc.movs(a, 0xFF);
  cc.movs(a, 0xFF00);
  cc.movs(a, 0xFF000000);
  cc.movs(a, 0xF000000F);
  cc.movt(a, 1);
  cc.movw(a, 1);
  cc.mul(a, b, c);
  cc.muls(a, b, c);
  cc.mvn(a, b, lsl(c));
  cc.mvn(a, b, lsr(c));
  cc.mvn(a, b, asr(c));
  cc.mvn(a, b, ror(c));
  cc.mvn(a, b, lsl(8));
  cc.mvn(a, b, lsr(8));
  cc.mvn(a, b, asr(8));
  cc.mvn(a, b, ror(8));
  cc.mvn(a, 0xFF);
  cc.mvn(a, 0xFF00);
  cc.mvn(a, 0xFF000000);
  cc.mvn(a, 0xF000000F);
  cc.mvns(a, b, lsl(c));
  cc.mvns(a, b, lsr(c));
  cc.mvns(a, b, asr(c));
  cc.mvns(a, b, ror(c));
  cc.mvns(a, b, lsl(8));
  cc.mvns(a, b, lsr(8));
  cc.mvns(a, b, asr(8));
  cc.mvns(a, b, ror(8));
  cc.mvns(a, 0xFF);
  cc.mvns(a, 0xFF00);
  cc.mvns(a, 0xFF000000);
  cc.mvns(a, 0xF000000F);
  cc.orr(a, b, c, lsl(d));
  cc.orr(a, b, c, lsr(d));
  cc.orr(a, b, c, asr(d));
  cc.orr(a, b, c, ror(d));
  cc.orr(a, b, c, lsl(8));
  cc.orr(a, b, c, lsr(8));
  cc.orr(a, b, c, asr(8));
  cc.orr(a, b, c, ror(8));
  cc.orr(a, b, 0xFF);
  cc.orr(a, b, 0xFF00);
  cc.orr(a, b, 0xFF000000);
  cc.orr(a, b, 0xF000000F);
  cc.orrs(a, b, c, lsl(d));
  cc.orrs(a, b, c, lsr(d));
  cc.orrs(a, b, c, asr(d));
  cc.orrs(a, b, c, ror(d));
  cc.orrs(a, b, c, lsl(8));
  cc.orrs(a, b, c, lsr(8));
  cc.orrs(a, b, c, asr(8));
  cc.orrs(a, b, c, ror(8));
  cc.orrs(a, b, 0xFF);
  cc.orrs(a, b, 0xFF00);
  cc.orrs(a, b, 0xFF000000);
  cc.orrs(a, b, 0xF000000F);
  cc.pkhbt(a, b, c, lsl(8));
  cc.pkhtb(a, b, c, asr(8));
  cc.qadd(a, b, c);
  cc.qadd16(a, b, c);
  cc.qadd8(a, b, c);
  cc.qasx(a, b, c);
  cc.qdadd(a, b, c);
  cc.qdsub(a, b, c);
  cc.qsax(a, b, c);
  cc.qsub(a, b, c);
  cc.qsub16(a, b, c);
  cc.qsub8(a, b, c);
  cc.rbit(a, b);
  cc.rev(a, b);
  cc.rev16(a, b);
  cc.revsh(a, b);
  cc.ror(a, b, 3);
  cc.ror(a, b, c);
  cc.rors(a, b, 3);
  cc.rors(a, b, c);
  cc.rrx(a, b);
  cc.rrxs(a, b);
  cc.rsb(a, b, c, lsl(d));
  cc.rsb(a, b, c, lsr(d));
  cc.rsb(a, b, c, asr(d));
  cc.rsb(a, b, c, ror(d));
  cc.rsb(a, b, c, lsl(8));
  cc.rsb(a, b, c, lsr(8));
  cc.rsb(a, b, c, asr(8));
  cc.rsb(a, b, c, ror(8));
  cc.rsb(a, b, 0xFF);
  cc.rsb(a, b, 0xFF00);
  cc.rsb(a, b, 0xFF000000);
  cc.rsb(a, b, 0xF000000F);
  cc.rsbs(a, b, c, lsl(d));
  cc.rsbs(a, b, c, lsr(d));
  cc.rsbs(a, b, c, asr(d));
  cc.rsbs(a, b, c, ror(d));
  cc.rsbs(a, b, c, lsl(8));
  cc.rsbs(a, b, c, lsr(8));
  cc.rsbs(a, b, c, asr(8));
  cc.rsbs(a, b, c, ror(8));
  cc.rsbs(a, b, 0xFF);
  cc.rsbs(a, b, 0xFF00);
  cc.rsbs(a, b, 0xFF000000);
  cc.rsbs(a, b, 0xF000000F);
  cc.rsc(a, b, c, lsl(d));
  cc.rsc(a, b, c, lsr(d));
  cc.rsc(a, b, c, asr(d));
  cc.rsc(a, b, c, ror(d));
  cc.rsc(a, b, c, lsl(8));
  cc.rsc(a, b, c, lsr(8));
  cc.rsc(a, b, c, asr(8));
  cc.rsc(a, b, c, ror(8));
  cc.rsc(a, b, 0xFF);
  cc.rsc(a, b, 0xFF00);
  cc.rsc(a, b, 0xFF000000);
  cc.rsc(a, b, 0xF000000F);
  cc.rscs(a, b, c, lsl(d));
  cc.rscs(a, b, c, lsr(d));
  cc.rscs(a, b, c, asr(d));
  cc.rscs(a, b, c, ror(d));
  cc.rscs(a, b, c, lsl(8));
  cc.rscs(a, b, c, lsr(8));
  cc.rscs(a, b, c, asr(8));
  cc.rscs(a, b, c, ror(8));
  cc.rscs(a, b, 0xFF);
  cc.rscs(a, b, 0xFF00);
  cc.rscs(a, b, 0xFF000000);
  cc.rscs(a, b, 0xF000000F);
  cc.sadd16(a, b, c);
  cc.sadd8(a, b, c);
  cc.sasx(a, b, c);
  cc.sbc(a, b, c, lsl(d));
  cc.sbc(a, b, c, lsr(d));
  cc.sbc(a, b, c, asr(d));
  cc.sbc(a, b, c, ror(d));
  cc.sbc(a, b, c, lsl(8));
  cc.sbc(a, b, c, lsr(8));
  cc.sbc(a, b, c, asr(8));
  cc.sbc(a, b, c, ror(8));
  cc.sbc(a, b, 0xFF);
  cc.sbc(a, b, 0xFF00);
  cc.sbc(a, b, 0xFF000000);
  cc.sbc(a, b, 0xF000000F);
  cc.sbcs(a, b, c, lsl(d));
  cc.sbcs(a, b, c, lsr(d));
  cc.sbcs(a, b, c, asr(d));
  cc.sbcs(a, b, c, ror(d));
  cc.sbcs(a, b, c, lsl(8));
  cc.sbcs(a, b, c, lsr(8));
  cc.sbcs(a, b, c, asr(8));
  cc.sbcs(a, b, c, ror(8));
  cc.sbcs(a, b, 0xFF);
  cc.sbcs(a, b, 0xFF00);
  cc.sbcs(a, b, 0xFF000000);
  cc.sbcs(a, b, 0xF000000F);
  cc.sbfx(a, b, 3, 5);
  cc.sdiv(a, b, c);
  cc.sel(a, b, c);
  cc.shadd16(a, b, c);
  cc.shadd8(a, b, c);
  cc.shasx(a, b, c);
  cc.shsax(a, b, c);
  cc.shsub16(a, b, c);
  cc.shsub8(a, b, c);
  cc.smlabb(a, b, c, d);
  cc.smlabt(a, b, c, d);
  cc.smlad(a, b, c, d);
  cc.smladx(a, b, c, d);
  cc.smlal(a, b, c, d);
  cc.smlalbb(a, b, c, d);
  cc.smlalbt(a, b, c, d);
  cc.smlald(a, b, c, d);
  cc.smlaldx(a, b, c, d);
  cc.smlals(a, b, c, d);
  cc.smlaltb(a, b, c, d);
  cc.smlaltt(a, b, c, d);
  cc.smlatb(a, b, c, d);
  cc.smlatt(a, b, c, d);
  cc.smlawb(a, b, c, d);
  cc.smlawt(a, b, c, d);
  cc.smlsd(a, b, c, d);
  cc.smlsdx(a, b, c, d);
  cc.smlsld(a, b, c, d);
  cc.smlsldx(a, b, c, d);
  cc.smmla(a, b, c, d);
  cc.smmlar(a, b, c, d);
  cc.smmls(a, b, c, d);
  cc.smmlsr(a, b, c, d);
  cc.smmul(a, b, c);
  cc.smmulr(a, b, c);
  cc.smuad(a, b, c);
  cc.smuadx(a, b, c);
  cc.smulbb(a, b, c);
  cc.smulbt(a, b, c);
  cc.smull(a, b, c, d);
  cc.smulls(a, b, c, d);
  cc.smultb(a, b, c);
  cc.smultt(a, b, c);
  cc.smulwb(a, b, c);
  cc.smulwt(a, b, c);
  cc.smusd(a, b, c);
  cc.smusdx(a, b, c);
  cc.ssat(a, 8, c);
  cc.ssat(a, 8, c, lsl(8));
  cc.ssat(a, 8, c, asr(8));
  cc.ssat16(a, 8, c);
  cc.ssax(a, b, c);
  cc.ssub16(a, b, c);
  cc.ssub8(a, b, c);
  cc.str(a, ptr(b, c));
  cc.str(a, ptr_pre(b, c));
  cc.str(a, ptr_post(b, c));
  cc.str(a, ptr(b, 4));
  cc.str(a, ptr_pre(b, 4));
  cc.str(a, ptr_post(b, 4));
  cc.strb(a, ptr(b, c));
  cc.strb(a, ptr_pre(b, c));
  cc.strb(a, ptr_post(b, c));
  cc.strb(a, ptr(b, 4));
  cc.strb(a, ptr_pre(b, 4));
  cc.strb(a, ptr_post(b, 4));
  cc.strbt(a, ptr_post(b, c));
  cc.strbt(a, ptr_post(b, 4));
  cc.strh(a, ptr(b, c));
  cc.strh(a, ptr_pre(b, c));
  cc.strh(a, ptr_post(b, c));
  cc.strh(a, ptr(b, 4));
  cc.strh(a, ptr_pre(b, 4));
  cc.strh(a, ptr_post(b, 4));
  cc.strht(a, ptr_post(b, c));
  cc.strht(a, ptr_post(b, 4));
  cc.strt(a, ptr_post(b, c));
  cc.strt(a, ptr_post(b, 4));
  cc.sub(a, b, c, lsl(d));
  cc.sub(a, b, c, lsr(d));
  cc.sub(a, b, c, asr(d));
  cc.sub(a, b, c, ror(d));
  cc.sub(a, b, c, lsl(8));
  cc.sub(a, b, c, lsr(8));
  cc.sub(a, b, c, asr(8));
  cc.sub(a, b, c, ror(8));
  cc.sub(a, b, 0xFF);
  cc.sub(a, b, 0xFF00);
  cc.sub(a, b, 0xFF000000);
  cc.sub(a, b, 0xF000000F);
  cc.subs(a, b, c, lsl(d));
  cc.subs(a, b, c, lsr(d));
  cc.subs(a, b, c, asr(d));
  cc.subs(a, b, c, ror(d));
  cc.subs(a, b, c, lsl(8));
  cc.subs(a, b, c, lsr(8));
  cc.subs(a, b, c, asr(8));
  cc.subs(a, b, c, ror(8));
  cc.subs(a, b, 0xFF);
  cc.subs(a, b, 0xFF00);
  cc.subs(a, b, 0xFF000000);
  cc.subs(a, b, 0xF000000F);
  cc.sxtab(a, b, c, ror(8));
  cc.sxtab16(a, b, c, ror(8));
  cc.sxtah(a, b, c, ror(8));
  cc.sxtb(a, b, ror(8));
  cc.sxtb16(a, b, ror(8));
  cc.sxth(a, b, ror(8));
  cc.teq(a, b, lsl(c));
  cc.teq(a, b, lsr(c));
  cc.teq(a, b, asr(c));
  cc.teq(a, b, ror(c));
  cc.teq(a, b, lsl(8));
  cc.teq(a, b, lsr(8));
  cc.teq(a, b, asr(8));
  cc.teq(a, b, ror(8));
  cc.teq(a, 0xFF);
  cc.teq(a, 0xFF00);
  cc.teq(a, 0xFF000000);
  cc.teq(a, 0xF000000F);
  cc.tst(a, b, lsl(c));
  cc.tst(a, b, lsr(c));
  cc.tst(a, b, asr(c));
  cc.tst(a, b, ror(c));
  cc.tst(a, b, lsl(8));
  cc.tst(a, b, lsr(8));
  cc.tst(a, b, asr(8));
  cc.tst(a, b, ror(8));
  cc.tst(a, 0xFF);
  cc.tst(a, 0xFF00);
  cc.tst(a, 0xFF000000);
  cc.tst(a, 0xF000000F);
  cc.uadd16(a, b, c);
  cc.uadd8(a, b, c);
  cc.uasx(a, b, c);
  cc.ubfx(a, b, 3, 5);
  cc.udiv(a, b, c);
  cc.uhadd16(a, b, c);
  cc.uhadd8(a, b, c);
  cc.uhasx(a, b, c);
  cc.uhsax(a, b, c);
  cc.uhsub16(a, b, c);
  cc.uhsub8(a, b, c);
  cc.umaal(a, b, c, d);
  cc.umlal(a, b, c, d);
  cc.umlals(a, b, c, d);
  cc.umull(a, b, c, d);
  cc.umulls(a, b, c, d);
  cc.uqadd16(a, b, c);
  cc.uqadd8(a, b, c);
  cc.uqasx(a, b, c);
  cc.uqsax(a, b, c);
  cc.uqsub16(a, b, c);
  cc.uqsub8(a, b, c);
  cc.usad8(a, b, c);
  cc.usada8(a, b, c, d);
  cc.usat(a, 8, c, lsl(8));
  cc.usat(a, 8, c, asr(8));
  cc.usat16(a, 8, c);
  cc.usax(a, b, c);
  cc.usub16(a, b, c);
  cc.usub8(a, b, c);
  cc.uxtab(a, b, c, ror(8));
  cc.uxtab16(a, b, c, ror(8));
  cc.uxtah(a, b, c, ror(8));
  cc.uxtb(a, b, ror(8));
  cc.uxtb16(a, b, ror(8));
  cc.uxth(a, b, ror(8));
}

static void generateGpSequence(BaseEmitter& emitter, bool emitPrologEpilog) {
  if (emitter.isAssembler()) {
    a32::Assembler& cc = *emitter.as<a32::Assembler>();

    a32::Gp a = a32::r0;
    a32::Gp b = a32::r1;
    a32::Gp c = a32::r2;
    a32::Gp d = a32::r3;

    if (emitPrologEpilog) {
      FuncDetail func;
      func.init(FuncSignature::build<void, void*, const void*, size_t>(), cc.environment());

      FuncFrame frame;
      frame.init(func);
      frame.addDirtyRegs(a, b, c, d);
      frame.finalize();

      cc.emitProlog(frame);
      generateGpSequenceInternal(cc, a, b, c, d);
      cc.emitEpilog(frame);
    }
    else {
      generateGpSequenceInternal(cc, a, b, c, d);
    }
  }
}

template<typename EmitterFn>
static void benchmarkA32Function(Arch arch, uint32_t numIterations, const char* description, const EmitterFn& emitterFn) noexcept {
  CodeHolder code;
  printf("%s:\n", description);

  uint32_t instCount = 0;

#ifndef ASMJIT_NO_BUILDER
  instCount = asmjit_perf_utils::calculateInstructionCount<a32::Builder>(code, arch, [&](a32::Builder& emitter) {
    emitterFn(emitter, false);
  });
#endif

  asmjit_perf_utils::bench<a32::Assembler>(code, arch, numIterations, "[raw]", instCount, [&](a32::Assembler& emitter) {
    emitterFn(emitter, false);
  });

  printf("\n");
}

void benchmarkA32Emitters(uint32_t numIterations) {
  static const char description[] = "GpSequence (Sequence of GP instructions)";
  benchmarkA32Function(Arch::kARM, numIterations, description, [](BaseEmitter& emitter, bool emitPrologEpilog) {
    generateGpSequence(emitter, emitPrologEpilog);
  });
}

#endif // !ASMJIT_NO_AARCH32
