// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_BASE_ERROR_H
#define _ASMJIT_BASE_ERROR_H

// [Api-Begin]
#include "../base/apibegin.h"

namespace asmjit {

//! @addtogroup asmjit_base
//! @{

// ============================================================================
// [asmjit::kError]
// ============================================================================

//! @brief AsmJit error codes.
ASMJIT_ENUM(kError) {
  //! @brief No error (success).
  //!
  //! This is default state and state you want.
  kErrorOk = 0,

  //! @brief Heap memory allocation failed.
  kErrorNoHeapMemory = 1,
  //! @brief Virtual memory allocation failed.
  kErrorNoVirtualMemory = 2,

  //! @brief Invalid argument.
  kErrorInvalidArgument = 3,
  //! @brief Invalid state.
  kErrorInvalidState = 4,

  //! @brief Unknown instruction. This happens only if instruction code is
  //! out of bounds. Shouldn't happen.
  kErrorAssemblerUnknownInst = 5,
  //! @brief Illegal instruction, usually generated by asmjit::Assembler
  //! class when emitting instruction opcode. If this error is generated the
  //! target buffer is not affected by this invalid instruction.
  //!
  //! You can also get this status code if you are under x64 (64-bit x86) and
  //! you tried to decode instruction using AH, BH, CH or DH register with REX
  //! prefix. These registers can't be accessed if REX prefix is used and AsmJit
  //! didn't check for this situation in intrinsics (@c Compiler takes care of
  //! this and rearrange registers if needed).
  //!
  //! Examples that will raise @c kErrorAssemblerIllegalInst error (a is
  //! @c Assembler instance):
  //!
  //! @code
  //! a.mov(dword_ptr(eax), al); // Invalid address size.
  //! a.mov(byte_ptr(r10), ah);  // Undecodable instruction (AH used with r10
  //!                            // that can be encoded by using REX prefix only)
  //! @endcode
  //!
  //! @note In debug mode you get assertion failure instead of setting error
  //! code.
  kErrorAssemblerIllegalInst = 6,
  //! @brief Illegal addressing used (unencodable).
  kErrorAssemblerIllegalAddr = 7,
  //! @brief Short jump instruction used, but displacement is out of bounds.
  kErrorAssemblerIllegalShortJump = 8,

  //! @brief No function defined.
  kErrorCompilerNoFunc = 9,
  //! @brief Function generation is not finished by using @c Compiler::endFunc()
  //! or something bad happened during generation related to function. This can
  //! be missing compiler node, etc...
  kErrorCompilerIncompleteFunc = 10,
  //! @brief Tried to generate a function with overlapped arguments.
  kErrorCompilerOverlappedArgs = 11,

  //! @brief Compiler can't allocate registers.
  kErrorCompilerNoRegs = 12,
  //! @brief Compiler can't allocate registers, because they overlap.
  kErrorCompilerOverlappedRegs = 13,

  //! @brief Tried to call function with an incompatible argument.
  kErrorCompilerIncompatibleArg = 14,
  //! @brief Incompatible return value.
  kErrorCompilerIncompatibleRet = 15,

  //! @brief Count of AsmJit status codes. Can grow in future.
  kErrorCount = 16
};

// ============================================================================
// [asmjit::Error]
// ============================================================================

typedef uint32_t Error;

// ============================================================================
// [asmjit::ErrorHandler]
// ============================================================================

struct ErrorHandler {
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref ErrorHandler.
  ASMJIT_API ErrorHandler();
  //! @brief Destroy the @ref ErrorHandler.
  ASMJIT_API virtual ~ErrorHandler();

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  //! @brief Reference this error handler.
  //!
  //! @note This member function is provided for convenience. The default
  //! implementation does nothing. If you are working in environment where
  //! multiple @ref ErrorHandler instances are used in different @ref Assembler
  //! and @ref Compiler instances (or in multithreaded environment) you might
  //! want to provide your own functionality for reference counting. In that
  //! case override @ref addRef() and @ref release() functions to inc/dec your
  //! reference count value.
  ASMJIT_API virtual ErrorHandler* addRef() const;

  //! @brief Release this error handler.
  //!
  //! @note This member function is provided for convenience. See @ref addRef()
  //! for more detailed information related to reference counting.
  ASMJIT_API virtual void release();

  //! @brief Error handler (pure).
  //!
  //! Error handler is called when an error happened. An error can happen in
  //! many places, but error handler is mostly used by @ref Assembler and
  //! @ref Compiler classes to report anything that may prevent correct code
  //! generation. There are multiple ways how the error handler can be used
  //! and each has it's pros/cons.
  //!
  //! AsmJit library doesn't use exceptions and can be compiled with or without
  //! exception feature support. Even if the AsmJit library is compiled without
  //! exceptions it is exception-safe and handleError() can report an incoming
  //! error by throwing an exception of any type. It's guaranteed that the
  //! exception won't be catched by AsmJit and will be propagated to the code
  //! calling AsmJit @ref Assembler or @ref Compiler. Alternative to throwing
  //! exception is using setjmp() / longjmp() pair from the standard C library.
  //!
  //! If the exception or setjmp() / longjmp() mechanism is used, the state of
  //! the @ref Assember or @ref Compiler is unchanged and if it's possible the
  //! execution (instruction serialization) can continue. However if the error
  //! happened during any phase that translates or modifies the stored code
  //! (for example relocation done by @ref Assembler or analysis/translation
  //! done by @ref Compiler) the execution can't continue and the error will
  //! be also stored in @ref Assembler or @ref Compiler.
  //!
  //! Finally, if exceptions nor setjmp() / longjmp() mechanisms were used,
  //! you can still implement a compatible design by returning from your error
  //! handler. Returning @c true means that error was reported and AsmJit
  //! should continue execution. When @c false is returned, AsmJit sets the
  //! error immediately to the @ref Assembler or @ref Compiler and execution
  //! shouldn't continue (this is the default behavior in case no error handler
  //! is used).
  virtual bool handleError(Error code, const char* message) = 0;
};

// ============================================================================
// [asmjit::ErrorUtil]
// ============================================================================

struct ErrorUtil {
  //! @brief Get printable version of AsmJit @ref kError code.
  static ASMJIT_API const char* asString(Error code);
};

// ============================================================================
// [ASMJIT_PROPAGATE_ERROR]
// ============================================================================

#define ASMJIT_PROPAGATE_ERROR(_Exp_) \
  do { \
    ::asmjit::Error errval_ = (_Exp_); \
    if (errval_ != ::asmjit::kErrorOk) \
      return errval_; \
  } while (0)

//! @}

} // asmjit namespace

// [Api-End]
#include "../base/apiend.h"

// [Guard]
#endif // _ASMJIT_BASE_ERROR_H
